# -*- coding: utf-8 -*-
from collections import OrderedDict

import six
from pyangbind.lib.base import PybindBase
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import YANGListType

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__

from . import available_core
from . import available_transceiver


class port(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = (
    '_path_helper', '_extmethods', '__port_id', '__layer_protocol_name', '__available_core', '__available_transceiver',)

    _yang_name = 'port'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__available_transceiver = YANGDynClass(base=available_transceiver.available_transceiver,
                                                    is_container='container', yang_name="available-transceiver",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True, extensions=None,
                                                    namespace='urn:node-topology', defining_module='node-topology',
                                                    yang_type='container', is_config=True)
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", available_core.available_core, yang_name="available-core", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='core-id', extensions=None), is_container='list', yang_name="available-core",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port']

    def _get_port_id(self):
        """
        Getter method for port_id, mapped from YANG variable /node/port/port_id (string)
        """
        return self.__port_id

    def _set_port_id(self, v, load=False):
        """
        Setter method for port_id, mapped from YANG variable /node/port/port_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_port_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_port_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__port_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_id(self):
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_layer_protocol_name(self):
        """
        Getter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        """
        return self.__layer_protocol_name

    def _set_layer_protocol_name(self, v, load=False):
        """
        Setter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_layer_protocol_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_layer_protocol_name() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__layer_protocol_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol_name(self):
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)

    def _get_available_core(self):
        """
        Getter method for available_core, mapped from YANG variable /node/port/available_core (list)
        """
        return self.__available_core

    def _set_available_core(self, v, load=False):
        """
        Setter method for available_core, mapped from YANG variable /node/port/available_core (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_core is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_core() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("core_id", available_core.available_core, yang_name="available-core",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='core-id', extensions=None),
                             is_container='list', yang_name="available-core", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_core must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("core_id",available_core.available_core, yang_name="available-core", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list', yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__available_core = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_core(self):
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", available_core.available_core, yang_name="available-core", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='core-id', extensions=None), is_container='list', yang_name="available-core",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
            is_config=True)

    def _get_available_transceiver(self):
        """
        Getter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        """
        return self.__available_transceiver

    def _set_available_transceiver(self, v, load=False):
        """
        Setter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_transceiver is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_transceiver() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=available_transceiver.available_transceiver, is_container='container',
                             yang_name="available-transceiver", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='container',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_transceiver must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=available_transceiver.available_transceiver, is_container='container', yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__available_transceiver = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_transceiver(self):
        self.__available_transceiver = YANGDynClass(base=available_transceiver.available_transceiver,
                                                    is_container='container', yang_name="available-transceiver",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True, extensions=None,
                                                    namespace='urn:node-topology', defining_module='node-topology',
                                                    yang_type='container', is_config=True)

    port_id = __builtin__.property(_get_port_id, _set_port_id)
    layer_protocol_name = __builtin__.property(_get_layer_protocol_name, _set_layer_protocol_name)
    available_core = __builtin__.property(_get_available_core, _set_available_core)
    available_transceiver = __builtin__.property(_get_available_transceiver, _set_available_transceiver)

    _pyangbind_elements = OrderedDict(
        [('port_id', port_id), ('layer_protocol_name', layer_protocol_name), ('available_core', available_core),
         ('available_transceiver', available_transceiver), ])
